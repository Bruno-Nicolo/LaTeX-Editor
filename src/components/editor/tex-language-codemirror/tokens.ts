import {
  ExternalTokenizer,
  InputStream,
  Stack,
  ContextTracker,
} from "@lezer/lr";

// !!!! IMPORTANT !!!!
// The following const declarations are PLACEHOLDERS.
// You MUST replace them with actual imports from the terms file
// generated by lezer-generator (e.g., ./tex.grammar.terms.js or ./parser.terms.js)
// once you compile your tex.grammar file.
// Example: import { left_brace, right_brace, ... } from "./parser.terms";

export const left_brace = 1; // {
export const right_brace = 2; // }
export const tab_mark = 3; // &
export const car_ret = 4; // newline
export const mac_param = 5; // #
export const sup_mark = 6; // ^
export const sub_mark = 7; // _
export const ignore = 8; // (e.g., NUL character)
export const spacer = 9; // space, tab
export const letter = 10; // a-z, A-Z
export const other_char = 11; // other printable characters
export const active_char = 12; // (e.g., ~)
export const invalid_char = 13; // (e.g., DEL character)
export const line_comment = 14; // %
// export const directive_comment = 15; // Omitted for this simple tokenizer
export const left_math_shift = 16; // $
export const right_math_shift = 17; // $
export const left_double_math_shift = 18; // $$
export const right_double_math_shift = 19; // $$
export const control_sequence_token = 20; // \command, \char
// export const primitive_token = 21;      // Omitted, treated as control_sequence_token
// Tokens from {{{tokens}}} in grammar are also omitted for this simple tokenizer

// --- Character Codes ---
const Backslash = 92; // '\'
const Percent = 37; // '%'
const BraceL = 123; // '{'
const BraceR = 125; // '}'
const Dollar = 36; // '$'
const Hash = 35; // '#'
const Caret = 94; // '^'
const Underscore = 95; // '_'
const Ampersand = 38; // '&'
const Tilde = 126; // '~' (common active_char)
const Tab = 9; // '\t'
const NulCh = 0; // NUL character (catcode 9 - ignore)
const DelCh = 127; // DEL character (catcode 15 - invalid)
const LF = 10; // Line Feed '\n'
const CR = 13; // Carriage Return '\r'
const Space = 32; // Space

function isAlpha(ch: number): boolean {
  return (ch >= 65 && ch <= 90) || (ch >= 97 && ch <= 122); // A-Z, a-z
}

function isTeXSpace(ch: number): boolean {
  return ch === Space || ch === Tab;
}

// --- Context Tracker for Math Shifts ---
// This helps distinguish between opening and closing $ and $$
const enum MathState {
  None, // Not in math mode
  InSingle, // Inside $...$
  InDouble, // Inside $$...$$
}

// The grammar file (tex.grammar) specifies `@context trackContext from "../tokens"`,
// so we must export a ContextTracker, and Lezer will pick it up if it's the only one
// or if it's named `trackContext`. We name it explicitly for clarity.
export const trackContext = new ContextTracker<MathState>({
  start: MathState.None,
  shift: (context, term, _stack, _input) => {
    if (term === left_math_shift) return MathState.InSingle;
    if (term === left_double_math_shift) return MathState.InDouble;
    // This logic relies on the tokenizer emitting the correct 'right' shift token
    if (term === right_math_shift && context === MathState.InSingle)
      return MathState.None;
    if (term === right_double_math_shift && context === MathState.InDouble)
      return MathState.None;
    return context;
  },
  hash: (context) => context,
});

export const tokenizer = new ExternalTokenizer(
  (input: InputStream, stack: Stack) => {
    // Get current math state from context tracker
    const currentMathState =
      stack.context.getValue(trackContext) ?? MathState.None;
    const first = input.next();

    if (first === Backslash) {
      input.advance(); // Consume '\'
      const second = input.next();
      if (isAlpha(second)) {
        input.advance(); // Consume first letter
        while (isAlpha(input.next())) {
          input.advance();
        }
      } else if (
        second !== -1 &&
        second !== LF &&
        second !== CR &&
        !isTeXSpace(second)
      ) {
        // Consume a single non-alphabetic, non-EOF, non-newline, non-space character after \
        input.advance();
      } else {
        // Backslash followed by EOF, newline, or space is often just a control space or error
        // For simplicity, we treat \<space> as a control sequence token (like \ ).
        // If it's \<EOF> or \<newline>, it might be an incomplete sequence or an error.
        // A robust tokenizer might handle this differently or emit an error token.
        // Here, if it's not a char to form a sequence, we've already consumed backslash.
        // If second was -1, nothing more to consume. If it was space/NL, it's part of the command token.
        // This part can be refined based on desired TeX dialect specifics.
        if (second === -1) {
          /* EOF after \, just emit control_sequence_token for \ */
        } else {
          input.advance();
        } // Consume the space/NL/etc as part of the token
      }
      input.acceptToken(control_sequence_token);
      return;
    }

    if (first === Percent) {
      input.advance(); // Consume '%'
      while (
        input.next() !== LF &&
        input.next() !== CR &&
        input.next() !== -1
      ) {
        input.advance();
      }
      input.acceptToken(line_comment);
      return;
    }

    if (first === BraceL) {
      input.advance();
      input.acceptToken(left_brace);
      return;
    }
    if (first === BraceR) {
      input.advance();
      input.acceptToken(right_brace);
      return;
    }

    if (first === Dollar) {
      input.advance(); // Consume the first $
      if (input.next() === Dollar) {
        // Check for $$
        input.advance(); // Consume the second $
        // Use context to decide if it's opening or closing
        if (currentMathState === MathState.InDouble) {
          input.acceptToken(right_double_math_shift);
        } else {
          input.acceptToken(left_double_math_shift);
        }
      } else {
        // It's a single $
        if (currentMathState === MathState.InSingle) {
          input.acceptToken(right_math_shift);
        } else {
          input.acceptToken(left_math_shift);
        }
      }
      return;
    }

    if (first === Hash) {
      input.advance();
      input.acceptToken(mac_param);
      return;
    }
    if (first === Caret) {
      input.advance();
      input.acceptToken(sup_mark);
      return;
    }
    if (first === Underscore) {
      input.advance();
      input.acceptToken(sub_mark);
      return;
    }
    if (first === Ampersand) {
      input.advance();
      input.acceptToken(tab_mark);
      return;
    }
    if (first === Tilde) {
      input.advance();
      input.acceptToken(active_char);
      return;
    }

    if (first === NulCh) {
      input.advance();
      input.acceptToken(ignore);
      return;
    }
    if (first === DelCh) {
      input.advance();
      input.acceptToken(invalid_char);
      return;
    }

    // Newlines (car_ret)
    if (first === LF || first === CR) {
      input.advance();
      if (first === CR && input.next() === LF) input.advance(); // Handle CRLF
      input.acceptToken(car_ret);
      return;
    }

    // Spacer tokens (space or tab)
    if (isTeXSpace(first)) {
      input.advance();
      while (isTeXSpace(input.next())) {
        input.advance();
      }
      input.acceptToken(spacer);
      return;
    }

    // Letter tokens
    if (isAlpha(first)) {
      input.advance();
      while (isAlpha(input.next())) {
        input.advance();
      }
      input.acceptToken(letter);
      return;
    }

    // If it's not EOF and hasn't been matched, it's an 'other_char'
    if (first !== -1) {
      input.advance();
      input.acceptToken(other_char);
      return;
    }
  }
);
